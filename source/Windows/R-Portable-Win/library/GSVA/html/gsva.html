<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Gene Set Variation Analysis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for gsva {GSVA}"><tr><td>gsva {GSVA}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Gene Set Variation Analysis
</h2>

<h3>Description</h3>

<p>Estimates GSVA enrichment scores.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'ExpressionSet,list'
gsva(expr, gset.idx.list, annotation,
    method=c("gsva", "ssgsea", "zscore", "plage"),
    kcdf=c("Gaussian", "Poisson", "none"),
    abs.ranking=FALSE,
    min.sz=1,
    max.sz=Inf,
    parallel.sz=0,
    parallel.type="SOCK",
    mx.diff=TRUE,
    tau=switch(method, gsva=1, ssgsea=0.25, NA),
    ssgsea.norm=TRUE,
    verbose=TRUE)
## S4 method for signature 'ExpressionSet,GeneSetCollection'
gsva(expr, gset.idx.list, annotation,
    method=c("gsva", "ssgsea", "zscore", "plage"),
    kcdf=c("Gaussian", "Poisson", "none"),
    abs.ranking=FALSE,
    min.sz=1,
    max.sz=Inf,
    parallel.sz=0,
    parallel.type="SOCK",
    mx.diff=TRUE,
    tau=switch(method, gsva=1, ssgsea=0.25, NA),
    ssgsea.norm=TRUE,
    verbose=TRUE)
## S4 method for signature 'matrix,GeneSetCollection'
gsva(expr, gset.idx.list, annotation,
    method=c("gsva", "ssgsea", "zscore", "plage"),
    kcdf=c("Gaussian", "Poisson", "none"),
    abs.ranking=FALSE,
    min.sz=1,
    max.sz=Inf,
    parallel.sz=0,
    parallel.type="SOCK",
    mx.diff=TRUE,
    tau=switch(method, gsva=1, ssgsea=0.25, NA),
    ssgsea.norm=TRUE,
    verbose=TRUE)
## S4 method for signature 'matrix,list'
gsva(expr, gset.idx.list, annotation,
    method=c("gsva", "ssgsea", "zscore", "plage"),
    kcdf=c("Gaussian", "Poisson", "none"),
    abs.ranking=FALSE,
    min.sz=1,
    max.sz=Inf,
    parallel.sz=0,
    parallel.type="SOCK",
    mx.diff=TRUE,
    tau=switch(method, gsva=1, ssgsea=0.25, NA),
    ssgsea.norm=TRUE,
    verbose=TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>expr</code></td>
<td>
<p>Gene expression data which can be given either as an <code>ExpressionSet</code>
object or as a matrix of expression values where rows correspond
to genes and columns correspond to samples.</p>
</td></tr>
<tr valign="top"><td><code>gset.idx.list</code></td>
<td>
<p>Gene sets provided either as a <code>list</code> object or as a
<code>GeneSetCollection</code> object.</p>
</td></tr>
<tr valign="top"><td><code>annotation</code></td>
<td>
<p>In the case of calling <code>gsva()</code> with expression data in a <code>matrix</code>
and gene sets as a <code>GeneSetCollection</code> object, the <code>annotation</code> argument
can be used to supply the name of the Bioconductor package that contains
annotations for the class of gene identifiers occurring in the row names of
the expression data matrix. By default <code>gsva()</code> will try to match the
identifiers in <code>expr</code> to the identifiers in <code>gset.idx.list</code> just as
they are, unless the <code>annotation</code> argument is set.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>Method to employ in the estimation of gene-set enrichment scores per sample. By default
this is set to <code>gsva</code> (Hänzelmann et al, 2013) and other options are
<code>ssgsea</code> (Barbie et al, 2009), <code>zscore</code> (Lee et al, 2008) or <code>plage</code>
(Tomfohr et al, 2005). The latter two standardize first expression profiles into z-scores
over the samples and, in the case of <code>zscore</code>, it combines them together as their sum
divided by the square-root of the size of the gene set,
while in the case of <code>plage</code> they are used to calculate the singular value decomposition
(SVD) over the genes in the gene set and use the coefficients of the first right-singular vector
as pathway activity profile.</p>
</td></tr>
<tr valign="top"><td><code>kcdf</code></td>
<td>
<p>Character string denoting the kernel to use during the non-parametric estimation of the
cumulative distribution function of expression levels across samples when <code>method="gsva"</code>.
By default, <code>kcdf="Gaussian"</code> which is suitable when input expression values are continuous,
such as microarray fluorescent units in logarithmic scale, RNA-seq log-CPMs, log-RPKMs or log-TPMs.
When input expression values are integer counts, such as those derived from RNA-seq experiments,
then this argument should be set to <code>kcdf="Poisson"</code>.</p>
</td></tr>
<tr valign="top"><td><code>abs.ranking</code></td>
<td>
<p>Flag used only when <code>mx.diff=TRUE</code>. When <code>abs.ranking=FALSE</code> (default)
a modified Kuiper statistic is used to calculate enrichment scores, taking the magnitude
difference between the largest positive and negative random walk deviations. When
<code>abs.ranking=TRUE</code> the original Kuiper statistic that sums the largest positive and
negative random walk deviations, is used. In this latter case, gene sets with genes
enriched on either extreme (high or low) will be regarded as 'highly' activated.</p>
</td></tr>
<tr valign="top"><td><code>min.sz</code></td>
<td>
<p>Minimum size of the resulting gene sets.</p>
</td></tr>
<tr valign="top"><td><code>max.sz</code></td>
<td>
<p>Maximum size of the resulting gene sets.</p>
</td></tr>
<tr valign="top"><td><code>parallel.sz</code></td>
<td>
<p>Number of processors to use when doing the calculations in parallel.
This requires to previously load either the <code>parallel</code> or the
<code>snow</code> library. If <code>parallel</code> is loaded and this argument
is left with its default value (<code>parallel.sz=0</code>) then it will use
all available core processors unless we set this argument with a
smaller number. If <code>snow</code> is loaded then we must set this argument
to a positive integer number that specifies the number of processors to
employ in the parallel calculation.</p>
</td></tr>
<tr valign="top"><td><code>parallel.type</code></td>
<td>
<p>Type of cluster architecture when using <code>snow</code>.</p>
</td></tr>
<tr valign="top"><td><code>mx.diff</code></td>
<td>
<p>Offers two approaches to calculate the enrichment statistic (ES)
from the KS random walk statistic. <code>mx.diff=FALSE</code>: ES is calculated as
the maximum distance of the random walk from 0. <code>mx.diff=TRUE</code> (default): ES
is calculated as the magnitude difference between the largest positive
and negative random walk deviations.</p>
</td></tr>
<tr valign="top"><td><code>tau</code></td>
<td>
<p>Exponent defining the weight of the tail in the random walk performed by both the <code>gsva</code>
(Hänzelmann et al., 2013) and the <code>ssgsea</code> (Barbie et al., 2009) methods. By default,
this <code>tau=1</code> when <code>method="gsva"</code> and <code>tau=0.25</code> when <code>method="ssgsea"</code> just
as specified by Barbie et al. (2009) where this parameter is called <code>alpha</code>.</p>
</td></tr>
<tr valign="top"><td><code>ssgsea.norm</code></td>
<td>
<p>Logical, set to <code>TRUE</code> (default) with <code>method="ssgsea"</code> runs the SSGSEA method
from Barbie et al. (2009) normalizing the scores by the absolute difference between
the minimum and the maximum, as described in their paper. When <code>ssgsea.norm=FALSE</code>
this last normalization step is skipped.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>Gives information about each calculation step. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GSVA assesses the relative enrichment of gene sets across samples using
a non-parametric approach.  Conceptually, GSVA transforms a p-gene by n-sample
gene expression matrix into a g-geneset by n-sample pathway enrichment matrix.
This facilitates many forms of statistical analysis in the 'space' of pathways
rather than genes, providing a higher level of interpretability.
</p>
<p>The <code>gsva()</code> function first maps the identifiers in the gene sets to the
identifiers in the input expression data leading to a filtered collection of
gene sets. This collection can be further filtered to require a minimun and/or
maximum size of the gene sets for which we want to calculate GSVA enrichment
scores, by using the arguments <code>min.sz</code> and <code>max.sz</code>.
</p>


<h3>Value</h3>

<p>A gene-set by sample matrix of GSVA enrichment scores.
</p>


<h3>Author(s)</h3>

<p>J. Guinney and R. Castelo</p>


<h3>References</h3>

<p>Barbie, D.A. et al. Systematic RNA interference reveals that oncogenic KRAS-driven
cancers require TBK1. <em>Nature</em>, 462(5):108-112, 2009.
</p>
<p>Hänzelmann, S., Castelo, R. and Guinney, J.
GSVA: Gene set variation analysis for microarray and RNA-Seq data.
<em>BMC Bioinformatics</em>, 14:7, 2013.
</p>
<p>Lee, E. et al. Inferring pathway activity toward precise disease classification.
<em>PLoS Comp Biol</em>, 4(11):e1000217, 2008.
</p>
<p>Tomfohr, J. et al. Pathway level analysis of gene expression using singular value decomposition.
<em>BMC Bioinformatics</em>, 6:225, 2005.
</p>


<h3>See Also</h3>

<p><code><a href="filterGeneSets.html">filterGeneSets</a></code>
<code><a href="computeGeneSetsOverlap.html">computeGeneSetsOverlap</a></code>
</p>


<h3>Examples</h3>

<pre>

library(limma)

p &lt;- 10 ## number of genes
n &lt;- 30 ## number of samples
nGrp1 &lt;- 15 ## number of samples in group 1
nGrp2 &lt;- n - nGrp1 ## number of samples in group 2

## consider three disjoint gene sets
geneSets &lt;- list(set1=paste("g", 1:3, sep=""),
                 set2=paste("g", 4:6, sep=""),
                 set3=paste("g", 7:10, sep=""))

## sample data from a normal distribution with mean 0 and st.dev. 1
y &lt;- matrix(rnorm(n*p), nrow=p, ncol=n,
            dimnames=list(paste("g", 1:p, sep="") , paste("s", 1:n, sep="")))

## genes in set1 are expressed at higher levels in the last 'nGrp1+1' to 'n' samples
y[geneSets$set1, (nGrp1+1):n] &lt;- y[geneSets$set1, (nGrp1+1):n] + 2

## build design matrix
design &lt;- cbind(sampleGroup1=1, sampleGroup2vs1=c(rep(0, nGrp1), rep(1, nGrp2)))

## fit linear model
fit &lt;- lmFit(y, design)

## estimate moderated t-statistics
fit &lt;- eBayes(fit)

## genes in set1 are differentially expressed
topTable(fit, coef="sampleGroup2vs1")

## estimate GSVA enrichment scores for the three sets
gsva_es &lt;- gsva(y, geneSets, mx.diff=1)

## fit the same linear model now to the GSVA enrichment scores
fit &lt;- lmFit(gsva_es, design)

## estimate moderated t-statistics
fit &lt;- eBayes(fit)

## set1 is differentially expressed
topTable(fit, coef="sampleGroup2vs1")

</pre>

<hr /><div style="text-align: center;">[Package <em>GSVA</em> version 1.30.0 <a href="00Index.html">Index</a>]</div>
</body></html>
